<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/><meta name="exporter-version" content="Evernote Mac 6.0.8 (451398)"/><meta name="keywords" content="面试技术"/><meta name="created" content="2015-11-10 10:39:34 +0000"/><meta name="source-url" content="http://blog.csdn.net/lmj623565791/article/details/38960443"/><meta name="updated" content="2015-11-10 10:39:34 +0000"/><title>面试技术04: View的触摸事件机制</title></head><body style="word-wrap: break-word; -webkit-nbsp-mode: space; -webkit-line-break: after-white-space;">
1. 触摸事件的基本类型
<div>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1). down: 按下 </div><div>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2). move: 移动 </div><div>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3). up: 离开 </div><div><hr/></div><div>2. 事件对象产生的顺序</div><div>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1). down-->move-->move-->....-->up </div><div>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2). 每个事件对象产生后, 都会找到一个消费者来消费处理此事件 </div><div><hr/></div><div>3. 事件相关API</div><div>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1). MotionEvent: 代表对UI的操作单元的类,&nbsp;&nbsp;它的对象在用户触摸UI时系统自动创建基对象, 并将相关的数据保存在此对象中 </div><blockquote style="margin: 0 0 0 40px; border: none; padding: 0px;"><blockquote style="margin: 0 0 0 40px; border: none; padding: 0px;">ACTION_DOWN=0 : down类型值</blockquote><blockquote style="margin: 0 0 0 40px; border: none; padding: 0px;">ACTION_UP=1 : up类型值&nbsp;&nbsp;</blockquote><blockquote style="margin: 0 0 0 40px; border: none; padding: 0px;">ACTION_MOVE=2 : move类型值&nbsp;&nbsp;</blockquote><blockquote style="margin: 0 0 0 40px; border: none; padding: 0px;">int getAction() : 得到事件类型值</blockquote><blockquote style="margin: 0 0 0 40px; border: none; padding: 0px;"><br/></blockquote><blockquote style="margin: 0 0 0 40px; border: none; padding: 0px;">float getX() : 得到事件的X轴坐标(相对于当前View的左顶点)</blockquote><blockquote style="margin: 0 0 0 40px; border: none; padding: 0px;">float getRawX() :&nbsp;&nbsp;得到事件的X轴坐标(相对于屏幕的左顶点)</blockquote><blockquote style="margin: 0 0 0 40px; border: none; padding: 0px;">float getY() : 得到事件的Y轴坐标(相对于当前View的左顶点)</blockquote><blockquote style="margin: 0 0 0 40px; border: none; padding: 0px;"><div>float getRawY() :&nbsp;&nbsp;得到事件的Y轴坐标(相对于屏幕的左顶点)</div></blockquote></blockquote><div>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2). Activity </div><div>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;boolean dispatchTouchEvent(MotionEvent event) : 分发事件 &nbsp;&nbsp; </div><div>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;boolean onTouchEvent(MotionEvent event) : 处理事件的回调 </div><div>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3). View </div><div>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;boolean dispatchTouchEvent(MotionEvent event): 分发事件 </div><div>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </div><div>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;setOnClickListener(OnClickListener l) : 设置触摸事件监听器对象 </div><div>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;private OnTouchListener mOnTouchListener; //触摸事件监听器对象变量 </div><div>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;public interface OnTouchListener { &nbsp;&nbsp;//事件监听器接口 </div><div>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; boolean onTouch(View v, MotionEvent event); &nbsp;&nbsp;// 监听器对象的回调方法 </div><div>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} </div><div><br/></div><div>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;boolean onTouchEvent(MotionEvent event) &nbsp;&nbsp;: 事件监听回调方法 </div><div><br/></div><div>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;setOnclickListener(OnclickListener&nbsp;&nbsp;listener) : 设置点击监听器 </div><div>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;setOnLongClickListener(OnLongClickListener listener) : 设置长按事件监听器 </div><div>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;4). ViewGroup </div><div>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;boolean dispatchTouchEvent(MotionEvent ev) : 重写View的此方法, 如果当前ViewGroup不拦截, 会分发给对应的子View处理事件 </div><div>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;boolean onInterceptTouchEvent(MotionEvent ev) : 拦截触摸事件, 返回值如果为true表示拦截,后面的事件就会交给当前View来处理, 默认为false </div><div>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;requestDisallowInterceptTouchEvent(boolean disallowIntercept) : 如果参数为true, 使当前View及其外层的所有父View不能拦截后面的事件 </div><div><hr/></div><div>4. View的事件处理</div><div>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1). Touch事件的方法执行顺序:&nbsp;&nbsp; </div><div>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ①.&nbsp;&nbsp;dispatchTouchEvent() </div><div>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ②.&nbsp;&nbsp;setOnTouchListener的onTouch() </div><div>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ③. onTouchEvent() </div><div>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2). 执行的详细过程 </div><div>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ①. 在dispatchTouchEvent()会判断是否设置了Touch监听器? </div><div>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果没有直接进入② </div><div>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果有, 调用监听器的onTouch()方法, 如果onTouch方法返回true到此结束, 如果返回false进入② </div><div>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ②. 调用onTouchEvent() </div><div>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在down时, send一个延时500ms的消息准备触发长按事件监听回调) </div><div>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果0.5s内在产生了up事件, 此时就会移除长按的延时消息, 就会去执行点击事件监听回调 </div><div>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果0.5内没有产生up事件, 也没有离开, 就会调用长按事件监听回调方法, 如果返回的值是true就不可能再触发点击监听回调了, 否则还会触发. </div><div>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3). 说明: </div><div>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ①. 如果view的onTouch()(监听器回调)或onTouchEvent(监听回调)在down时返回true, 那第一个move事件就会交给当前View处理,&nbsp;&nbsp; </div><div>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;否则后面的所有事件都不会到达此View了 </div><div>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ②. 如是move事件处理返回true, 下一个move/up事件就会交给当前View处理,否则就会找父View或Activity处理 </div><div>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ③. 整体原则: 每个Event对象创建后, 最终肯定会有一个消费者: 可能是View, 也可能是ViewGroup, 实在不行就交给Activty消费处理 </div><div><hr/></div><div>5. ViewGroup的事件处理</div><div>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1). 相关方法执行顺序: </div><div>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ①.&nbsp;&nbsp;dispatchTouchEvent() </div><div>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ②.onInterceptTouchEvent() </div><div>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ③. 对应子View的dispatchTouchEvent() </div><div>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2). 执行的详细过程: </div><div>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ①.&nbsp;&nbsp;在dispatchTouchEvent()中,&nbsp;&nbsp;ACTION_DOWN时,&nbsp;&nbsp;判断是否拦截，如果没有拦截，则找到包含当前x,y坐标的子View，赋值给mMotionTarget， </div><div>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;然后调用mMotionTarget.dispatchTouchEvent()处理down事件 </div><div>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ②.&nbsp;&nbsp;在dispatchTouchEvent()中,&nbsp;&nbsp;ACTION_MOVE时,&nbsp;&nbsp;判断是否拦截，如果没有拦截，则直接调用mMotionTarget.dispatchTouchEvent(ev) </div><div>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ③.&nbsp;&nbsp;在dispatchTouchEvent()中,&nbsp;&nbsp;ACTION_UP时,&nbsp;&nbsp;判断是否拦截，如果没有拦截，则直接调用mMotionTarget.dispatchTouchEvent(ev) </div><div>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ④.&nbsp;&nbsp;如果没有找到合适的子View来消费当前event, 则将自己当成View来处理event </div><div>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3). 关于拦截: </div><div>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ①.  <font color="#E30000">如何拦截?</font>: ViewGroup中onInterceptTouchEvent()默认返回false, 也就是不拦截, 如果想拦截就重写此方法, 并返回true, 这样事件就不会分发给子View处理</div><div>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ②.&nbsp;&nbsp; <font color="#E30000">如何不被拦截?</font>: 如果子View不希望父View(也就是当前ViewGroup)拦截event, 子View可以执行:&nbsp;&nbsp;getParent().requestDisallowInterceptTouchEvent(true)</div><div><hr/></div><div>6. 扩展blog:</div><div>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a href="http://blog.csdn.net/lmj623565791/article/details/38960443">Android View 事件分发机制 源码解析</a></div><div>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a href="http://blog.csdn.net/lmj623565791/article/details/39102591">Android ViewGroup事件分发机制</a></div><div>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </div><div>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a href="http://blog.csdn.net/guolin_blog/article/details/9097463">Android事件分发机制完全解析，带你从源码的角度彻底理解(上)</a></div><div>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a href="http://blog.csdn.net/guolin_blog/article/details/9153747">Android事件分发机制完全解析，带你从源码的角度彻底理解(下)</a></div><div><br/></div><div><br/></div><div>分发</div><div>处理</div><div>消费</div><div>拦截</div><div>反拦截</div><div><br/></div></body></html>