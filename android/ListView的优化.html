<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/><meta name="exporter-version" content="Evernote Mac 6.0.8 (451398)"/><meta name="keywords" content="面试技术"/><meta name="created" content="2015-11-10 10:39:34 +0000"/><meta name="updated" content="2015-11-10 10:39:34 +0000"/><title>面试技术06: ListView的优化</title></head><body style="word-wrap: break-word; -webkit-nbsp-mode: space; -webkit-line-break: after-white-space;"><div><b>0. 第0层: 不优化:</b></div><div>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;每次执行getView(), 都会执行:&nbsp;&nbsp;&nbsp;&nbsp;converterView = View.inflate(R.layout.xxx); </div><div>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;问题: 效率太低, 在快速滑动时会有卡顿, 在数据很多时甚至会内存溢出 </div><div><hr/></div><b>1. 第一层: 复用converterView</b><div>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if(converterView==null) { </div><div>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; converterView = View.inflate(R.layout.xxx); &nbsp;&nbsp;//n+1 </div><div>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} </div><div>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </div><div>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;问题: 每次执行getView()都需要执行converterView.findViewById()得到子View &nbsp;&nbsp; ImageView </div><div><hr/></div><div><b>2. 第二层: 使用ViewHolder, 减少findViewById()的次数</b></div><div>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Viewholder holder = null; </div><div>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if(converterView==null) { </div><div>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; converterView = View.inflate(R.layout.xxx); </div><div>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;holder = new ViewHolder(); </div><div>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;holder.imageView = (ImageView)converterView.findViewById(xxx); </div><div>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; holder.textView = (TextView)converterView.findViewById(yyy); </div><div>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; converterView.setTag(holder); </div><div>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} else { </div><div>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; holder = (Viewholder&nbsp;&nbsp;)converterView.getTag(); </div><div>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} </div><div><br/></div><div>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Person p = data.get(position); </div><div>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;holder.imageView.setimage(p.getIcon()) </div><div>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;holder.textView.setText(p.getName()) </div><div><br/></div><div>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;static class ViewHolder { </div><div>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ImageView imageView; </div><div>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; TextView textView; </div><div>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} </div><div>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </div><div>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//json: [{}, {}] </div><div>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;问题1: 对于联网获取列表数据, 如果数据量太大(比如超过100000条甚至更多), 一次获取出来显示, 太慢太耗流量: 第四层优化 </div><div>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;问题2:&nbsp;&nbsp;对于联网获取列表数据, 如果包含图片数据, 每次都请求获取显示,&nbsp;&nbsp;太慢太耗流量: 第三层优化 </div><div><hr/></div><div><b>3. 第三层优化: 图片三级缓存处理</b></div><div>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;参见 <b>图片三级缓存机制</b></div><div><hr/></div><div><b>4. 第四层: 对数据列表进行分页加载显示</b></div><div>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1). 自己做: 通过Scroll监听listView.setonScrollListener(scrollListener), 当到达底部时加载下一页列表数据并显示 </div><div>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2). 使用第三方开源框架: Android-PullToRefresh或其它 </div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div></body></html>