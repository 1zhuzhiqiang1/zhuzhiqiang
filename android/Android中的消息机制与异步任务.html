<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/><meta name="exporter-version" content="Evernote Mac 6.0.8 (451398)"/><meta name="keywords" content="面试技术"/><meta name="created" content="2015-11-10 10:39:36 +0000"/><meta name="updated" content="2015-11-10 11:11:30 +0000"/><title>面试技术05: Android中的消息机制与异步任务</title></head><body style="word-wrap: break-word; -webkit-nbsp-mode: space; -webkit-line-break: after-white-space;"><span style="font-size: 19px;">1. 相关基础知识:</span><div style="font-size: 19px;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1). 在Android中, 运行的线程有两种类型: UIThread(主线程, 一个)和WorkerThread(分线程, 多个) <br/><div>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2).&nbsp;&nbsp;在Android中,只有在UIThread中才能 <b>直接</b>更新界面, 如果在分线程直接更新界面, 会抛出如下异常:</div><div>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;android.view.ViewRoot$CalledFromWrongThreadException: Only the original thread&nbsp;&nbsp; </div><div>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; that created a view hierarchy can touch its views. </div><div>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3). 在Android中,&nbsp;&nbsp;很多长时间处理数据的工作(联网)都需要在workerThread中执行, 否则会抛出异常/操作反应慢 </div><div>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;4). 在分线程得到数据后, 需要去更新界面, 但在分线程中直接更新界面是不允许的, 如何解决此矛盾? </div><div>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;5). 联网相关功能的三步: </div><div>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ①. 显示提示视图: 可能是ProgressBar, 也可能是ProgressDialog. ----在主线程执行 </div><div>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ②. 请求服务器, 得到服务器返回的数据. ----在分线程执行 </div><div>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ③. 更新界面: 移除提示视图, 显示得到的数据. ----在主线程执行 </div><div><hr/></div><div>2. 消息机制:</div><div>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1). Android中设计的一套API和完善的运行工作体系, 它能解决如何情况 </div><div>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ①. 分线程与主线程之间的多线程间通信 </div><div>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ②. 在一个线程内, 工作的统一处理 </div><div>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ③. 轻松实现延迟工作, &nbsp;&nbsp;循环工作,&nbsp;&nbsp;定时工作 </div><div><hr/></div><div>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2). 相关API: </div><div>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ①. Message: &nbsp;&nbsp;消息类 </div><div>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Message.obtain(what) : 创建消息对象 </div><div>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;public int what : 标识值 </div><div>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;public int arg1 : 携带Int类型数据 </div><div>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;public int arg2&nbsp;&nbsp;: 携带Int类型数据 </div><div>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;public Object obj&nbsp;&nbsp;: 携带任意对象类型数据 </div><div>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;public long when : 标识当前Message什么时刻应该被处理 </div><div>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;public Handler target : 当前message由哪个handler来分发处理 </div><div><br/></div><div>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ②. Handler: 处理器类 </div><div>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;sendMessage(Message msg) :&nbsp;&nbsp;&nbsp;&nbsp; 发送即时消息 </div><div>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;sendMessageDelayed(Message msg, long&nbsp;&nbsp;delayMillis) :&nbsp;&nbsp;发送延时消息 </div><div>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;sendEmptyMessage(int what): 发送即时空消息 </div><div>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;sendEmptyMessageDelayed(int what, long&nbsp;&nbsp;delayMillis) :&nbsp;&nbsp;发送延时空消息 </div><div>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;boolean post(Runnable r) : 发送即时带回调的空消息 </div><div>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;boolean postDelayed(Runnable r, long delayMillis): 发送延时带回调的空消息 </div><div><br/></div><div>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;handleMessage(Message msg) :&nbsp;&nbsp;处理消息的回调方法 </div><div>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </div><div>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;removeMessages(int what) : 根据what删除还未处理的对应消息 </div><div>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;removeCallbacksAndMessages(null) : 删除所有未处理的消息 </div><div>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </div><div>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dispatchMessage(Message msg) : 分发消息 </div><div>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;message的回调 </div><div>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;handler的callback监听器的回调方法 </div><div>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;handler的回调方法 </div><div>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ③. MessageQueue: 消息队列类(我们不需要操作)&nbsp;&nbsp; </div><div>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;enqueueMessage(Message msg, long when): 将消息添加到消息队列 </div><div>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 无论发送的是即时消息还是延时消息, 都是立即将message对象保存到了MessageQueue对象中 </div><div>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Message next() : 取出一个需要处理的消息, 如果没有就会进入等待状态, 但不会导致UIThread阻塞 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;thread.wait() </div><div>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ④. Looper: 循环器类(我们不需要操作)&nbsp;&nbsp; </div><div>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;loop() : 使用无限for循环获取message, 并调用对应的handler分发处理此消息 </div><div><hr/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3). 原理 </div><div>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <img src="%E9%9D%A2%E8%AF%95%E6%8A%80%E6%9C%AF05%3A%20Android%E4%B8%AD%E7%9A%84%E6%B6%88%E6%81%AF%E6%9C%BA%E5%88%B6%E4%B8%8E%E5%BC%82%E6%AD%A5%E4%BB%BB%E5%8A%A1.resources/DD8A2956-1E8D-45D9-9785-59A247649A62.png" height="476" width="837"/></div><div>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <img src="%E9%9D%A2%E8%AF%95%E6%8A%80%E6%9C%AF05%3A%20Android%E4%B8%AD%E7%9A%84%E6%B6%88%E6%81%AF%E6%9C%BA%E5%88%B6%E4%B8%8E%E5%BC%82%E6%AD%A5%E4%BB%BB%E5%8A%A1.resources/F8D8153C-91B1-4711-AEC3-5700C4A765F6.png" height="510" width="681"/></div><div><br/></div><div><hr/></div><div>3.&nbsp;&nbsp;异步任务:&nbsp;&nbsp;AsyncTask</div><div>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1). 在使用AsyncTask之前, 我们可以使用Handler+Thread的方式实现异步任务的功能 </div><div>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2). AsyncTask的优势: </div><div>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 编码上: 更简洁, 使用更方便 </div><div>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 效率上: 由于AsyncTask内部使用的是 <b>线程池</b>, 能反复使用Thread对象进行分线程的处理工作, 而原生的方式每次都是新建Thread对象启动分线程</div><div>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3). 相关API: </div></div><blockquote style="margin: 0px 0px 0px 40px; border: none; padding: 0px; font-size: 19px;"><blockquote style="margin: 0 0 0 40px; border: none; padding: 0px;"><div>class&nbsp;&nbsp;AsyncTask<Params, Progress, Result></div><div>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Params 启动任务执行的输入参数，比如HTTP请求的URL。 </div><div>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Progress 后台任务执行的百分比。 </div><div>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Result 后台执行任务最终返回的结果，比如String。 </div></blockquote></blockquote><blockquote style="margin: 0px 0px 0px 40px; border: none; padding: 0px; font-size: 19px;"><blockquote style="margin: 0 0 0 40px; border: none; padding: 0px;">execute(Params... params) :&nbsp;&nbsp;</blockquote><blockquote style="margin: 0 0 0 40px; border: none; padding: 0px;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;启动任务, 开始任务的执行流程 </blockquote><blockquote style="margin: 0 0 0 40px; border: none; padding: 0px;">void onPreExecute() :&nbsp;&nbsp;</blockquote><blockquote style="margin: 0 0 0 40px; border: none; padding: 0px;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在分线程工作开始之前在UIThread中执行，一般用来显示提示视图 </blockquote><blockquote style="margin: 0 0 0 40px; border: none; padding: 0px;">Result doInBackground(Params... params) :&nbsp;&nbsp;</blockquote><blockquote style="margin: 0 0 0 40px; border: none; padding: 0px;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在workerThread中执行, 完成任务的主要工作，通常需要较长的时间 </blockquote><blockquote style="margin: 0 0 0 40px; border: none; padding: 0px;">void onPostExecute(Result result) &nbsp;&nbsp;&nbsp;&nbsp;</blockquote><blockquote style="margin: 0 0 0 40px; border: none; padding: 0px;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在doInBackground()执行完后在UIThread中执行,一般用来更新界面&nbsp;&nbsp; </blockquote><blockquote style="margin: 0 0 0 40px; border: none; padding: 0px;">publishProgress(Progress... values) :</blockquote><blockquote style="margin: 0 0 0 40px; border: none; padding: 0px;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在分线程中, 发布当前进度 </blockquote><blockquote style="margin: 0 0 0 40px; border: none; padding: 0px;">void onProgressUpdate(Progress... values) :&nbsp;&nbsp;</blockquote><blockquote style="margin: 0 0 0 40px; border: none; padding: 0px;"><div>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在主线程中更新进度 </div></blockquote></blockquote><div style="font-size: 19px;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;4). 原理: </div><div style="font-size: 19px;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; execute() </div><div style="font-size: 19px;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <img src="%E9%9D%A2%E8%AF%95%E6%8A%80%E6%9C%AF05%3A%20Android%E4%B8%AD%E7%9A%84%E6%B6%88%E6%81%AF%E6%9C%BA%E5%88%B6%E4%B8%8E%E5%BC%82%E6%AD%A5%E4%BB%BB%E5%8A%A1.resources/07D24077-C44E-4837-988F-2A6128FD3D27.png" height="488" width="701"/></div><div style="font-size: 19px;"><hr/></div><div style="font-size: 19px;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </div><div style="font-size: 19px;"><br/></div><div style="font-size: 19px;"><br/></div><div style="font-size: 19px;"><br/></div><div style="font-size: 19px;"><br/></div><div style="font-size: 19px;"><br/></div><div style="font-size: 19px;"><br/></div><div style="font-size: 19px;"><br/></div><div style="font-size: 19px;"><br/></div><div style="font-size: 19px;"><br/></div><div style="font-size: 19px;"><br/></div><div style="font-size: 19px;"><br/></div><div style="font-size: 19px;"><br/></div><div style="font-size: 19px;"><br/></div><div style="font-size: 19px;"><br/></div><div style="font-size: 19px;"><br/></div><div style="font-size: 19px;"><br/></div><div style="font-size: 19px;"><br/></div><div style="font-size: 19px;"><br/></div><div style="font-size: 19px;"><br/></div><div style="font-size: 19px;"><br/></div><div style="font-size: 19px;"><br/></div><div style="font-size: 19px;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </div></body></html>